

      __                __ ___ ___ ______ _______ 
.----|  |-----.--.--.--|  |   |   |   __ \    |  |
|  __|  |  _  |  |  |  _  |   |   |    __/       |
|____|__|_____|_____|_____|\_____/|___|  |__|____|
                                                    

The multi-purpose cloud&open VPN by [exa]

Needed goals:

Whole network consists of connected nodes, all with equal functionality.  Nodes
are connected in a mesh of any shape, topology really doesn't matter. The mesh
can transfer multiple protocols at once, with varying link addresses.

Optional goals:

Don't use a single malloc(), only stack/STL allocation allowed. (success!)

Made by:
[exa] exa.exa@gmail.com

License:
GNU GPLv3 (see LICENSE file)

Contents:
1] Compiling
2] Terminology
3] Internals
4] Protocol
5] Configuration

************************************************************* COMPILING *******

Use CMake:

$ cmake . && make

On Win32 you should try to use ported CMake along with MinGW32 compiler.
Should be achievable on Win64, though not tested.



*********************************************************** TERMINOLOGY *******


To achieve the goal of having CloudVPN as good as it should be, we need to
split it to several parts that work independently, and are freely pluggable.

Base part of the tools is called CORE. That is most similar to the old
CloudVPN, in means of connecting the peers to the mesh, and routing information
through the resulting network.

As we want the inlying protocol independency, the core is free from any
protocol-specific stuff. This means that Ethernet "TAP backends" and similar
communication agents are moved from the core to separate programs, which
connect to core using a special protocol, announce themselves, and send/receive
packets, expecting that core will eventually mesh them correctly to marked
destinations. Those programs will be called GATEs.

This requires core to distinguish between PROTOCOLS, so that it knows which
addresses are in one protocol and which aren't, and also whether given gate
will accept a packet or not. Therefore, gate implementations will have to agree
on a globally unique identifier of given protocol. (note: do not confuse
protocol IDs with next readme chapter called "protocol" because of describing
packet structures)

We might want to route more separate networks of one protocol on one mesh. This
implies that Protocol identifier will be needed to be combined with INSTANCE
identifier. Because of similarity of those identifiers, they are gonna be
probably united in higher/lower 32bit integer parts.

Finally, as authentication using SSL only is not sufficient in many situation,
each CloudVPN instance opens a special AUTH protocol socket, which can be used
by special daemon to decide what key IDs are allowed to connect at given time.
It is informed by simple instructions in form "Key XXX wants to connect" about
what goes on, and replies with "Key XXX authenticated" or "Key XXX access
denied", which can cause even disconnection of already-active connections.



************************************************************* INTERNALS *******


This section describes all the hacks used in how routing works.



************************************************************** PROTOCOL *******


This section describes how CloudVPN core communicates with other cores, gates,
and auth daemon.


********************************************************* CONFIGURATION *******


This section lists all configuration options available for running CloudVPN
core and some of the most important CloudVPN gates/auth daemons.



