      __                __ ___ ___ ______ _______ 
.----|  |-----.--.--.--|  |   |   |   __ \    |  |
|  __|  |  _  |  |  |  _  |   |   |    __/       |
|____|__|_____|_____|_____|\_____/|___|  |__|____|
                                                    

The cloud&clustering&open VPN by [exa]

Needed goals:

Whole network consists of connected nodes, all with equal functionality.
Nodes are connected in a mesh of any shape, topology really doesnt matter.
Each node works exactly like a simple mesh router.

Optional goals:

Don't use a single malloc(), only stack/STL allocation allowed. (success!)

Made by:
[exa] exa.exa@gmail.com

License:
GNU GPLv3 (see LICENSE file)

	*** COMPILING ***

Use SCons - just write scons in source directory and observe the result.
See details at http://www.scons.org/

For those who do not want to install scons, or python, or any other dependency,
there's a build.sh script in extras, which will compile the thing for you,
just as scons would. It can be also generated by gen-build.sh script.

So the rich pythonist makes a script (note he executed scons -c before),
$ extras/gen-build.sh > extras/build.sh
$ chmod +x extras/build.sh

so the poor assemblerist can write only:
$ extras/build.sh
...and watch it compile too.


	*** Win32 COMPILING ***

Win32 binary IS possible. You need:

a] Mingw32-g++ on some linux box
b] agree to the fact that Win32 TAP interface can't be polled, so you have to
   use dumb_poll method.
c] have openssl lib&include for win32 (for example from GnuWin32 project)

Then do this:

$ export CXX=i586-mingw32msvc-g++    (or any other mingw you have)
$ export WIN32                       (mark for scons - winsock, .exe,...)
$ scons

This should throw you .exe file, run it as you like.
Configuration is mostly the same as on any other system.


	*** IMPLEMENTATION NOTES ***

When connecting, nodes can act as server or client, therefore use server or
client SSL keys. Authorization to connect is given, when both sides have
certificates signed by the same certificate authority, signing a key means
allowing a client to connect to the network. Sign is verified once per
connection, so it can grow arbitrarily to enhance security.

we simulate "real ethernet". If a node wants to act as a real client, he
simply assigns himself some network address (preferably mac-like 6byte) and
waits for packet to this address, and sends packet which are for another
addresses to another nodes. Mac address collisions are possible!

All nodes can
	a] connect to (more) other or allow other to get a connection
	b] select one hw address that is "their" and handle the data
	   packets.

All nodes must
	a] act as switches in a mesh network. (NO tree, we allow circles)
	   -remember where which MAC address sits
	   -send packets which arent for our MAC to the other guys.
	   -do NOT duplicate data packets, unless they are marked as broadcasts.
	b] provide and update reasonable info about "what MACs I can send to"
	c] provide and update reasonable info about MAC distances, so there's a
	   possibility to select a best route for a packet.
	d] (maybe later) provide some possibility to choke given connection. If
	   a connection is choked, route packets elsewhere (NOT back). As the
	   ping packets are in the same stream as the normal packets, this will
	   probably not be needed to solve.
	e] if a connection to a node is lost, send the update info to
	   neighbors. Connection send queue gets discarded.
	f] treat unknown mac destination as a broadcast.

Every broadcast packet
	a] has a random-generated ID
	b] when handled, is sent to ALL connections (excl the one it came from),
	   and received by the MAC address
	c] must NOT be resent twice by the same node (therefore the sent-ID
	   cache)

Sent-ID cache
	a] does never expire by time
	b] has a maximal size

All clients must note, that
	a] we are simulating the REAL Ethernet with all its "feats", so
	   ARP spoofs, sniffing, and things like that ARE possible.
	b] They don't get any route and/or IP address with the connection, like
	   the OpenVPN guys do. This should be handled by some classical dhcp
	   server which sits on any host of the network (and is best at it).
	c] ONLY form of authentication (that server and client both fit into the
	   network here) IS actually the CA certification. Someone could look
	   for using the ssh-like server certificate change-checking, but this
	   could be a little complicated and not really usuable here, when we
	   assume that IF the attacker already has taken over the CA key, he is
	   not gonna have much trouble taking over (or maybe bruteforcing
	   similarly) the server key.

	*** OPTIONAL ROUTING ***
	 (multipath scattering)

A node can select to use optional routing scheme, that allows more effective
multipath packet sending.

Not that the classical routing couldn't handle that, the big difference here is
that new routing can use all "available" connection paths at any given time,
therefore balance throughput. Old routing uses only the one with best ping,
and does it for specific periods (which are usually around 5 seconds, as pings
get measured this often by default).

Please see documentation in the source (file src/route.cpp line ~100) before
you start using this. Such routing is not suitable for whole network.

Typical use of this routing is shown on the image here:

      -----S-----
     /     |     \      O's are the clients who want to communicate,
    O------S------O     S's are some servers,
     \     |     /      multipath is enabled only on O's
      -----S-----

	*** PACKET FORMAT ***

Connection and authentication is done through SSL
Multibyte integers are in network byte order.

struct NEIGHBOR --- (12B)
6B mac_addr
2B dist --real graph distance.
4B ping --distance in some measured units. Let it be the "ping"

struct packet_header --- (4B)
1B packet_type
1B special
2B size

PACKET TYPES are:

1 - route information set, size is the *count* of following neighbors
2 - route information diff, -"- .. diffs
3 - ethernet packet, followed by to[6],from[6],type[2],data[size-14]
4 - broadcast ethernet packet, followed by id[4], and the rest ^
5 - echo request, special == ID
6 - echo reply, special == ID
7 - complete route information request

NOTE that login/logout is handled by SSL

EVERY PACKET has format:

4B struct packet header
xB data


	*** CONFIGURATION ***

we should stay as simple as OpenVPN guys are -- command line parameters combined
with the config file of the same format, only without the "minuses".

Maybe files without parameter could specify "yes", it would be logical. unimpl.

IP adresses are in format IP [space] service, where IP can be IPv4, IPv6 or
DNS-type hostname, and port can be numerical port, or service name (e.g. 'http')

config options:

@include path

connect IP port  --repeat as needed, normal topology connect

conn_retry 10000000 -- how long to sleep after disconnect/conn fail

listen IP port --repeat as needed, should be set like 0.0.0.0 60606

ca path --load CA certificates from given file (this option may be repeated)
	--note that if your CA's are chained, whole chain is required to be
	--loaded. (may be splitted across more files)

crl path --load all certificate revocation lists from a file (also repeatable)

key path  --this key pair is used for both server and client connections
key_pass string  --key unlocker password
cert path  --public certificate (preferably signed by CA)


 -- iface on Linux

iface yes/no  --we can be headless
tunctl /dev/net/tun  --character device 10 major 200 minor
iface_dev tapX --for acquiring exact name/persistent device
iface_persist yes/no  --leave it for others
mac 00:00:00:00:00:00 --override autogenerated mac, probably unneeded


 -- iface on BSD; we are more file-based here. Should also work on OSX

iface yes/no
iface_device tap0  --remember NOT to specify tun.
mac 00:00:00:00:00:00

-- on the BSD, you should be able to create tap0 device by
-- '# ifconfig tap0 create'.
-- on OpenBSD, you NEED to specify tun0, because there's no tap:
-- '# ifconfig tun0 link0' makes it behave like a tap.


 -- local security

user cvpn   --switch user/group
group cvpn

chroot /some/dir --chroot things, to avoid hidden exploits
mlockall yes  --avoid swapping out sensitive data


 -- multipath scattering
 -- This can be especially vital for some situations, and totally unusuable
 -- for other. Be sure to read the docs in src/route.cpp line ~100

multipath yes  --enable
multi_ratio 2  --usually _should_ stay at default value


 -- bandwidth limiting

--these set maximal total/per-connection DATA bandwidth, in bytes per second.

uplimit-total 123
uplimit-conn 321
uplimit-burst 2048
downlimit-total 123
downlimit-conn 321
downlimit-burst 20480

--please note that the bandwidth we limit here is inner, and the thing gets
--recalculated by SSL encryption (so it can differ in new size.)
--if you want to limit real bandwidth, use your OS's tools.
--Also, dont rely on it to be exact. For that you _need_ OS tools.

--To get smoother upload line, please decrease max_waiting_* queue size values.

--downlimit-burst should always be a little larger, because we don't do
--any bandwidth queuing, but just drop things.


 -- socket options

tcp_nodelay yes   -- just sets TCP_NODELAY. see 'man 7 tcp'
ip_tos lowdelay|throughput|reliability|mincost
	--set IP type of service. see 'man 7 ip' for description


 -- network bridging - you usually need those options create a br0-like bridge

promisc yes -- enables the real promisc on tap0.

ignore_macs yes -- avoid bridged-MACs' collisions with the VPN's MACs.

broadcast_send yes -- send all packets as broadcasts. Usuable at bridging.

bridge_mode yes -- selects all the above options at once.

broadcast_nocopy yes
	--don't really broadcast the broadcast packets, only send one copy
	--to a random connection. usuable ONLY when you are multipath-connected
	--to ONE node (for example you have two ADSL's).
	--It otherwise WILL cripple real ethernet functionality.
	--The benefit lies at using the multipath much better.

--if you are doing a simple point-to-point bridge, you might also
--want to decrease the br_id_cache_size (to 16 or so). If there's more hosts,
--do _NOT_ decrease it.

 -- tuning

br_id_cache_size 1024 --broadcast ID cache size, in ID entries.
	--If rotating broadcasts kill your network, increase this.
route_max_dist 64 -- maximal distance of remote peers. Allows the network
	--to forget about the disappeared node. Increase as needed, decreasing
	--for unstable networks improves speed and decreases bandwidth.
max_remote_routes 256 -- maximal count of routes that connection can report.

-- increase these values to stabilize high route-info/TCP throughput
max_waiting_proto_packets 64
max_waiting_data_packets 256
max_input_queue_size 4194304

conn-mtu 8192  -- drop data packets larger than this.

heartbeat 50000 -- core update heartbeat in usec. Smaller values improve
	--overall responsiveness, especially neighbor-info spreading speed, at
	--a cost of slight overhead (global update is done once per period.)
	--Higher values dont harm much, but greater networks with frequent
	--topology changes may suffer.

listen_backlog 32 --parameter to listen(), maximum number of accept-pendings.

max_connections 1024 -- overall maximum number of communication channels.

conn_timeout 60000000 -- connection inactivity timeout.

conn_keepalive 5000000 -- ping interval

comm_close_timeout 10000000 -- how long to wait for connections to close
			-- valid only when shutting down

report_ping_changes_above 5000 -- usuable when route information updates fills
	too much network bandwidth.

ssl_method tls -- default ssl method to use. 'ssl' (SSLv3) is the second option

status-file /some/file -- file where to print nice information exports
status-interval 30000000 -- periodicity of the above
status-verbose yes -- also report routes of the connections

broadcast_filter_allow 0806 -- broadcast packet filter by EtherID
	-- when not specified, every EtherID is allowed

poll_interval 5000 -- amount of usec to wait between 2 dumb polls.
	-- You will use this on Win32. If you need ping, decrease;
	-- if it eats your precious CPU, increase.


	*** INTERNALS ***

modules are:

conf - command line parser, config file parser (@include is special option)
iface - local interface handler, creates/destroys iface, gets/writes packets.
comm - tcp/ssl wrapper, communication. Able to infinately retry some of
	the lost connections. Incoming packets and information is
	passed to route. output queue.
route - routing information for packets, send_id cache
utils - just some utilities
cloudvpn - the thing that reads the config and runs all of it
main.c - neatly separated main()
poll - waiting for events. epoll is default, select will be provided.
timestamp - usec timer
sq - packet buffer and socket data queue
security - bunch of securing tools (userswitch, chroot, mlock)

Please format the code using $ astyle --style=linux -pdt


	*** KEY GENERATOR, the openssl helper ***

For simplicity, I provide some basic openssl scripts which generate keys good
enough for the purpose of cloudvpning. Basic usage looks like this:

We have both RSA and DSA keys. Thanks to snajpa (snajpa@snajpa.net) for DSA.

cd keygen/dsa   --or /rsa. DSA is considered to be a little more secure.
mkdir my_keys
cd my_keys
../gen-dh
../gen-ca
../ca-selfsign   (or send the request to verisign, lol.)
KEY=ssl.key REQ=ssl.req ../gen-key
REQ_ssl.req OUT=ssl.crt ../ca-sign

Please remember to supply different common names for all keys, otherwise index
will get mad. If anything goes wrong, don't hesitate to use similar and more
sophisticated packages, like easy-rsa from openvpn, but remember to use correct
nsCertType purpose, for both client and server things.

