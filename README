      __                __ ___ ___ ______ _______ 
.----|  |-----.--.--.--|  |   |   |   __ \    |  |
|  __|  |  _  |  |  |  _  |   |   |    __/       |
|____|__|_____|_____|_____|\_____/|___|  |__|____|
                                                    

The cloud&clustering&open VPN by [exa]

Needed goals:

Whole network consists of connected nodes, all with equal functionality.
Nodes are connected in a mesh of any shape, topology really doesnt matter.

Optional goals:

Don't use a single malloc(), so everyone knows that STL is powerful enough as
a memory management alternative.

	*** IMPLEMENTATION NOTES ***

When connecting, nodes can act as server or client, therefore use server or
client SSL keys. Authorization to connect is given, when both sides have
certificates signed by the same certificate authority, signing a key means
allowing a client to connect to the network. Sign is verified once per
connection, so it can grow arbitrarily to enhance security.

we simulate "real ethernet". If a node wants to act as a real client, he
simply assigns himself some network address (preferably mac-like 6byte) and
waits for packet to this address, and sends packet which are for another
addresses to another nodes. Mac address collisions are possible!

All nodes can
	a] connect to (more) other or allow other to get a connection
	b] select one hw address that is "their" and handle the data
	   packets.

All nodes must
	a] act as switches in a graph network. (NO tree, we allow circles)
	   -remember where which MAC address is
	   -send packets which arent for our MAC to the other guys.
	   -do NOT duplicate data packets, unless they are marked as broadcasts.
	b] provide and update reasonable info about "what MACs I can send to"
	c] provide and update reasonable info about MAC distances, so there's a
	   possibility to select a best route for a packet.
	d] (maybe later) provide some possibility to choke given connection. If
	   a connection is choked, route packets elsewhere (NOT back). As the
	   ping packets are in the same queue as the normal packets, this will
	   probably not be needed to solve.
	e] if a connection to a node is lost, send the update info to
	   neighbors. Connection send queue gets discarded.
	f] treat unknown mac destination as a broadcast.

Every broadcast packet
	a] has a random-generated ID
	b] when handled, is sent to ALL connections (excl the one it came from),
	   and received by the MAC address
	c] must NOT be resent twice by the same node (therefore the sent-ID
	   cache)

Sent-ID cache
	a] does never expire by time
	b] has a maximal size

All clients must note, that
	a] we are simulating the REAL Ethernet with all its "feats", so
	   ARP spoofs, sniffing, and things like that ARE possible.
	b] They don't get any route and/or IP address with the connection, like
	   the OpenVPN guys do. This should be handled by some classical dhcp
	   server which sits on any host of the network (and is best at it).
	c] ONLY form of authentication (that server and client both fit into the
	   network here) IS actually the CA certification. Someone could look
	   for using the ssh-like server certificate change-checking, but this
	   could be a little complicated and not really usuable here, when we
	   assume that IF the attacker already has taken over the CA key, he is
	   not gonna have much trouble taking over (or maybe bruteforcing
	   similarly) the server key.

	*** PACKET FORMAT ***

Connection and authentication is done through SSL

struct NEIGHBOR --- (10B)
6B mac_addr
4B distance --distance is in relative units. Let it be the "ping"

struct packet_header --- (4B)
1B packet_type
1B special
2B size

PACKET TYPES are:

1 - route information set, size is the *count* of following neighbors
2 - route information add, -"-
3 - ethernet packet, followed by to[6],from[6],type[2],data[size]
4 - broadcast ethernet packet, followed by id[4], to[6], from[6], data[size]
5 - echo request, special == ID
6 - echo reply, special == ID

NOTE that login/logout is handled by SSL

EVERY PACKET has format:

4B struct packet header
xB data

	*** CONFIGURATION ***

we should stay as simple as OpenVPN guys are -- command line parameters combined
with the config file of the same format, only without the "minuses".

Maybe files without parameter could specify "yes", it would be logical. unimpl.

config options:

@include path

connect IP port  --repeat as needed, normal topology connect

connect_retry time   --in seconds, probably.

listen IP port --repeat as needed, should be set like 0.0.0.0 20

server_default_accept yes/no --ip connection policy
server_allow_mask IP/mask --repeat both as needed
server_reject_mask IP/mask

ca_cert path --auth
key path  --this key pair is used for both server and client connections
key_pass string  --key unlocker
cert path  --public certificate preferably signed by CA

iface yes/no  --we can be headless
tunctl /dev/net/tun  --character device 10 major 200 minor
iface_dev tapX --for acquiring exact name/persistent device
iface_persist yes/no  --leave it for others
mac 00:00:00:00:00:00 --override autogenerated mac, probably unneeded

 -- these will be probably defined later:
uid nobody
gid nobody

 -- tuning

br_id_cache_size 1024 --broadcast ID cache size, in ID entries.
	--If rotating broadcasts kill your network, increase this.
max_send_queue_size 262144 --maximum size of output queue, in bytes.
	--When you have too much communication problems in peaks, increase this.

	*** INTERNALS ***

modules are:

conf - command line parser, config file parser (@include is special option)
iface - local interface handler, creates/destroys iface, gets/writes packets.
comm - tcp/ssl wrapper, communication. Able to infinately retry some of
	the lost connections. Incoming packets and information is
	passed to route. output queue.
route - routing information for packets, send_id cache
utils - just some utilities
cloudvpn - the thing that reads the config and runs all of it
main.c - neatly separated main()
poll - waiting for events
timestamp - usec timer

Please format the code using $ astyle --style=linux -pdt

