      __                __ ___ ___ ______ _______ 
.----|  |-----.--.--.--|  |   |   |   __ \    |  |
|  __|  |  _  |  |  |  _  |   |   |    __/       |
|____|__|_____|_____|_____|\_____/|___|  |__|____|
                                                    

The cloud clustering open VPN by [exa]

Needed goals:

whole network consists of connected nodes, all with equal functionality.

when connecting, nodes can act as server or client, therefore use server or
client SSL keys. Authorization to connect is given, when both sides have
certificates signed by the same certificate authority, signing a key means
allowing a client to connect to the network. Sign is verified once per
connection, so it can grow arbitrarily to enhance security.

we simulate "real ethernet". If a node wants to act as a real client, he
simply assigns himself some network address (preferably mac-like 6byte) and
waits for packet to this address, and sends packet which are for another
addresses to another nodes. Client may even check if the address is not already
in use.

All nodes can
	a] connect to (more) other or allow other to get a connection
	b] select one hw address that is "their" and handle the data
	   packets.

All nodes must
	a] act as switches in a graph network. (NO tree, we allow circles)
	   -remember where which MAC address is
	   -send packets which arent for our MAC to the other guys.
	   -do NOT duplicate data packets.
	b] provide and update reasonable info about "what MACs I can send to"
	c] provide and update reasonable info about MAC distances, so there's a
	   possibility to select a best route for a packet.
	d] (maybe later) provide some possibility to choke given connection. If
	   a connection is choked, route packets elsewhere (NOT back).
	e] if a connection to a server is lost, send the update info to
	   neighbors, and then send all the packets to any alternative route,
	   possibly back.

Every broadcast packet
	a] has a random-generated ID
	b] when handled, is sent to ALL connections (excl the one it came from),
	   and received by the MAC address
	c] must NOT be resent twice by the same node (therefore the sent-ID
	   cache)

All clients must note, that
	a] we are simulating the real Ethernet LAN with all its "feats", so
	   ARP spoofs, sniffing, and things like that ARE possible.
	b] They don't get a route and/or IP address. This should be handled by
	   classical dhcp server which sits somewhere on the network.


*** PACKET FORMAT ***

Connection and authentication is done through SSL

MAC struct --- (8B)
6B mac_addr
2B distance

MAC INFO RESET packet ---   "hey thats exactly what I can have
NEW MAC packet ---
LOST MAC packet ---

1B id == 1 or 2 or 3
1B mac_count
( 8B struct mac ) * mac_count    --hey maan were sending le big macques

DATA packet ---

1B id == 4
6B source_mac
6B dest_mac
2B length
xB some data  --irl no need to checksum.

DATAB packet --- broadcast

1B ID == 5
6B source_mac
4B packet_ID   --to kill resending
2B length
xB some data

*** CONFIGURATION ***

we should stay as simple as OpenVPN guys are -- command line parameters combined
with the config file of the same format, only without the "minuses".

Maybe files without parameter could specify "yes", it would be logical.

config options:

@include path

connect IP:port  --repeat as needed
connection_retry time
client_cert path
client_key path

listen IP:port --repeat as needed
server_default_accept yes/no
server_allow_mask IP/mask --repeat both as needed
server_reject_mask IP/mask
server_key path
server_cert path

ca_cert path

iface yes/no
tunctl /dev/net/tun
iface_dev tapX --for example.
iface_persist yes/no
mac 00:00:00:00:00:00

 -- these will be probably defined later:
uid nobody
gid nobody


*** INTERNALS ***

modules are:

conf - command line parser, config file parser (@include is special option)
iface - local interface handler, creates/destroys iface, gets/writes packets.
comm - tcp/ssl wrapper, communication. Able to infinately retry some of
	the lost connections. Incoming packets and information is
	passed to route. output queue.
route - information about "which mac is where". information about broadcasts.
	iface connection.
cloudvpn - the thing that reads the config and runs all of it
main.c - neatly separated main()


